//
//  PageViewController.swift
//  PlainText2AttributedString
//
//  Created by Krzysztof Pawski on 10/02/16.
//  Copyright (c) 2016 Krzysztof Pawski. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

import UIKit

protocol PageViewControllerInput {
  func displayFetchedPages(viewModel: PageScene.FetchPages.ViewModel)
}

protocol PageViewControllerOutput {
  func fetchPages(request: PageScene.FetchPages.Request)
  func chapterTitle() -> String
  
  var tintColor: UIColor! { get set }
  var pageIndexToBeSelected: UInt! { get set }
  var chapterId: UInt! { get set }
}

final class PageViewController: UIViewController, PageViewControllerInput {
  
  var output: PageViewControllerOutput!
  var router: PageRouter!
  var tappedURL: NSURL?
  
  @IBOutlet weak var scrollView: UIScrollView!
  @IBOutlet weak var pageControl: UIPageControl?
  @IBOutlet weak var bottomConstraint: NSLayoutConstraint?
  
  var pages: [PageScene.FetchPages.ViewModel.PageViewModel]?
  var textViews: [UITextView] = []
  
  // MARK: Object lifecycle
  
  override func awakeFromNib() {
    super.awakeFromNib()
    PageConfigurator.sharedInstance.configure(self)
  }
  
  // MARK: View lifecycle
  
  override func viewDidLoad() {
    super.viewDidLoad()
    pageControl?.addTarget(self, action: #selector(pageControlDidChangeValue(_:)), forControlEvents: UIControlEvents.ValueChanged)
    pageControl?.pageIndicatorTintColor = output.tintColor
    pageControl?.hidden = true
    scrollView.delegate = self
    scrollView.backgroundColor = Configuration.pagesBackgroundColor
    view.backgroundColor = Configuration.pagesBackgroundColor
    automaticallyAdjustsScrollViewInsets = false
    fakeInitialization()
  }
  
  //for testing purpose
  func fakeInitialization() {
    output.chapterId = 1
    output.pageIndexToBeSelected = 0
  }
  
  override func viewWillAppear(animated: Bool) {
    super.viewWillAppear(animated)
    navigationItem.title = output.chapterTitle()
    
    performSelector(#selector(fetchPagesOnLoad), withObject: nil, afterDelay: 0.1)
  }
  
  override func viewWillDisappear(animated: Bool) {
    super.viewWillDisappear(animated)
    output.pageIndexToBeSelected = UInt(pageControl!.currentPage)
  }
  
  // MARK: Display logic
  
  func displayFetchedPages(viewModel: PageScene.FetchPages.ViewModel) {
    pages = viewModel.pageModels
    reloadPages()
    
    pageControl?.currentPage = Int(output.pageIndexToBeSelected)
    selectPage(output.pageIndexToBeSelected, animated: false)
  }
  
  // MARK: Event handling
  
  func fetchPagesOnLoad() {
    let request = PageScene.FetchPages.Request()
    output.fetchPages(request)
  }
  
  func reloadPages() {
    guard (scrollView != nil) else {
      return
    }
    
    //clear scrollview
    for tv in textViews {
      tv.removeFromSuperview()
    }
    textViews.removeAll()
    
    if ((pages == nil) || (pages!.count == 0)) {
      displayMissingContentAlert()
      return
    }
    
    let offset = scrollView.contentOffset
    scrollView.contentOffset = CGPointZero
    scrollView.contentSize = CGSizeMake(CGFloat(pages!.count) * CGRectGetWidth(view.frame), CGRectGetHeight(scrollView.frame) - 244.0)
    pageControl?.hidden = (pages!.count <= 1)
    pageControl?.numberOfPages = (pages!.count > 1) ? pages!.count : 0
    view.layoutIfNeeded()
    
    for i in 1...pages!.count {
      let page = pages![i - 1]
      let textView = configuredTextView(i)
      textView.attributedText = page.content
      scrollView.addSubview(textView)
      textViews.append(textView)
    }
    
    dispatch_async(dispatch_get_main_queue()) { () -> Void in
      self.scrollView.setContentOffset(offset, animated: false)
    }
  }
  
  func displayMissingContentAlert() {
    let alertController = UIAlertController(title: "Missing content",
                                            message: "Sorry, the content for this chapter has not been provided yet. Patience you must have.",
                                            preferredStyle: UIAlertControllerStyle.Alert)
    let okAction = UIAlertAction(title: "OK", style: UIAlertActionStyle.Default, handler: nil)
    alertController.addAction(okAction)
    presentViewController(alertController, animated: true, completion: nil)
  }
  
  func configuredTextView(atIndex: Int) -> UITextView {
    let textView = CustomTextView(frame: scrollView.bounds)
    textView.delegate = self
    textView.frame = CGRectOffset(textView.frame, CGFloat(atIndex - 1) * CGRectGetWidth(view.frame), 0)
    return textView
  }
  
  // MARK: PageControll
  
  func pageControlDidChangeValue(sender: UIPageControl) {
    selectPage(UInt(sender.currentPage), animated: true)
  }
  
  func selectPage(index: UInt, animated: Bool) {
    dispatch_async(dispatch_get_main_queue()) { () -> Void in
      self.scrollView.setContentOffset(CGPoint(x: CGFloat(index) * CGRectGetWidth(self.view.frame), y: self.scrollView.contentOffset.y), animated: animated)
      self.pageControl?.currentPage = Int(index)
    }
  }
  
  // MARK: Rotation
  
  override func didRotateFromInterfaceOrientation(fromInterfaceOrientation: UIInterfaceOrientation) {
    output.pageIndexToBeSelected = UInt(pageControl!.currentPage)
    selectPage(0, animated: false)
    reloadPages()
    selectPage(output.pageIndexToBeSelected, animated: false)
  }
}

extension PageViewController: UIScrollViewDelegate {
  func scrollViewDidScroll(aScrollView: UIScrollView) {
    if (scrollView != aScrollView) {
      return
    }
    let index = Int(aScrollView.contentOffset.x / CGRectGetWidth(aScrollView.frame))
    pageControl?.currentPage = Int(index)
  }
}

extension PageViewController: UITextViewDelegate {
  func textView(textView: UITextView, shouldInteractWithURL URL: NSURL, inRange characterRange: NSRange) -> Bool {
    if (URL.absoluteString.hasPrefix("showChapter/")) {
      // display linked chapter
      return false
    } else if (URL.absoluteString.hasPrefix("showResource/")) {
      // display linked resource
      return false
    }
    else if (URL.absoluteString.hasPrefix("www") || URL.absoluteString.hasPrefix("http")) {
      // display web
      return false
    }
    return true
  }
  
  func textView(textView: UITextView, shouldInteractWithTextAttachment textAttachment: NSTextAttachment, inRange characterRange: NSRange) -> Bool {
    guard let image = textAttachment.image else {
      return true
    }
    displayImageViewer(characterRange, textView: textView, image: image)
    return true
  }

  func displayImageViewer(range: NSRange, textView: UITextView, image: UIImage) {
    let rect = textView.layoutManager.boundingRectForGlyphRange(range, inTextContainer: textView.textContainer)
    let rectRange = textView.convertRect(rect, fromView: textView.textInputView)
    let rectRangeSuper = scrollView.convertRect(rectRange, fromView: textView)
    let rectView = textView.frame
    var rectIntersect = CGRectIntersection(rectRangeSuper, rectView)
    if (CGRectIsNull(rectIntersect) == true) {
      // something went wrong...
      return
    }
    
    rectIntersect.origin.x = rect.origin.x
    
    let imageViewer = ImageViewer(image: image)
    imageViewer.frame = rectIntersect
    view.addSubview(imageViewer)
    
    UIView.animateWithDuration(0.5) { () -> Void in
      imageViewer.frame = self.view.frame
    }
  }
}


